---
title: "[ Rust笔记 四] 基础-函数"
categories: 
 - 技术
tags:
 - Rust
date: 2025/08/08 16:56:25
updated: 2025/08/08 16:56:25
---

### 简介

```
    fn add1(t : (i32, i32)) -> i32 { //模式解构
        t.0 + t.1
    }
	
	fn add2((x, y) : (i32, i32)) -> i32 {//和上述写法一样
        x + y
    }
	
	
    fn main() {
        // 先让 func 指向 add1
        let mut func = add1;
        // 再重新赋值，让 func 指向 add2
        func = add2;
    }

```

会报错，类型不一致。每个函数都有自己得类型。

```	
	// 写法一，用 as 类型转换
    let mut func = add1 as fn((i32, i32))->i32;
    // 写法二，用显式类型标记
    let mut func : fn((i32, i32))->i32 = add1;
```	
	
Rust的函数体内也允许定义其他item，包括静态变量、常量、函数、trait、类型、模块等。

```
	fn test_inner() {
        static INNER_STATIC: i64 = 42;
        // 函数内部定义的函数
        fn internal_incr(x: i64) -> i64 {
            x + 1
        }
        struct InnerTemp(i64);
        impl InnerTemp {
            fn incr(&mut self) {
                self.0 = internal_incr(self.0);
            }
        }
        // 函数体，执行语句
        let mut t = InnerTemp(INNER_STATIC);
        t.incr();
        println!("{}", t.0);
    }
```

### 发散函数

```
    fn diverges() -> ! {
        panic! ("This function never returns! ");
    }

    let x : i32 = diverges();
    let y : String = diverges();

    let p = if x {
        panic!("error");
    } else {
        100
    };	
```	
**可以被转换成任意类型**
	
<!--more-->

在Rust中，有以下这些情况永远不会返回，它们的类型就是！。
1. panic！以及基于它实现的各种函数/宏，比如unimplemented! 、unreachable!；
1. 死循环loop {}；
1. 进程退出函数std::process::exit以及类似的libc中的exec一类函数。
	
### main函数

```
    fn main() {
        for arg in std::env::args() {
            println!("Arg: {}", arg);
        }
        std::process::exit(0);
    }
   
    $ test -opt1 opt2-- opt3
    Arg: test
    Arg: -opt1
    Arg: opt2
    Arg: --
    Arg: opt3
```	

```
fn main() {
	 for arg in std::env::args() {
     match std::env::var(&arg) {
          Ok(val) => println!("{}: {:? }", &arg, val),
          Err(e) => println!("couldn't find environment {}, {}", &arg, e),
     }
   }
   println!("All environment varible count {}", std::env::vars().count());
}
```	
	
### const fn
函数可以用const关键字修饰，这样的函数可以在编译阶段被编译器执行，返回值也被视为编译期常量。

```
#! [feature(const_fn)]
const fn cube(num: usize) -> usize {
    num ＊ num ＊ num
}
fn main() {
    const DIM : usize = cube(2);
    const ARR : [i32; DIM] = [0; DIM];
    println!("{:? }", ARR);
}	
```

### 递归函数

```
    fn fib(index: u32) -> u64 {
        if index == 1 || index == 2 {
            1
        } else {
            fib(index -1) + fib(index -2)
        }
    }
    fn main() {
        let f8 = fib(8);
        println!("{}", f8);
    }
```    