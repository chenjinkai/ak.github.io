---
title: "[ Rust笔记 五] 基础-trait"
categories: 
 - 技术
tags:
 - Rust
date: 2025/08/11 11:00:00
updated: 2025/08/11 11:00:00
---

### 成员方法

```
    trait Shape {
        fn area(&self) -> f64;//关联函数，参数被称为接收者
    }

    trait T {
        fn method1(self: Self);
        fn method2(self: &Self);
        fn method3(self: &mut Self);
    }
    // 上下两种写法是完全一样的
    trait T {
        fn method1(self);
        fn method2(&self);
        fn method3(&mut self);
    }
```
具有receiver参数的函数，我们称为“方法”​（method）​，可以通过变量实例使用小数点来调用。
没有receiver参数的函数，我们称为“静态函数”​（static function）​，可以通过类型加双冒号：:的方式来调用。

Rust中Self（大写S）和self（小写s）都是关键字，大写S的是类型名，小写s的是变量名。

```
    struct Circle {
        radius: f64,
    }
    impl Shape for Circle {
        // Self 类型就是 Circle
        // self 的类型是 &Self，即 &Circle
        fn area(&self) -> f64 {
            // 访问成员变量，需要用 self.radius
            std::f64::consts::PI ＊ self.radius ＊ self.radius
        }
    }
    fn main() {
        let c = Circle { radius : 2f64};
        // 第一个参数名字是 self，可以使用小数点语法调用
        println!("The area is {}", c.area());
    }
```

另一种写法“内在方法”

```
    impl Circle {
        fn get_radius(&self) -> f64 { self.radius }
    }
```
trait中可以包含方法的默认实现。如果这个方法在trait中已经有了方法体，那么在针对具体类型实现的时候，就可以选择不用重写。

<!--more-->

self参数甚至可以是Box指针类型self

```
    trait Shape {
        fn area(self: Box<Self>) -> f64;
    }
    struct Circle {
        radius: f64,
    }
    impl Shape for Circle {
        // Self 类型就是 Circle
        // self 的类型是 Box<Self>，即 Box<Circle>
        fn area(self : Box<Self>) -> f64 {
            // 访问成员变量，需要用 self.radius
            std::f64::consts::PI ＊ self.radius ＊ self.radius
        }
    }
    fn main() {
        let c = Circle { radius : 2f64};
        // 编译错误
        // c.area();
        let b = Box::new(Circle {radius : 4f64});
        // 编译正确
        b.area();
    }
```

```
    trait Shape {
        fn area(self: Box<Self>) -> f64;
    }
    struct Circle {
        radius: f64,
    }
    impl Shape for Circle {
        // Self 类型就是 Circle
        // self 的类型是 Box<Self>，即 Box<Circle>
        fn area(self : Box<Self>) -> f64 {
            // 访问成员变量，需要用 self.radius
            std::f64::consts::PI ＊ self.radius ＊ self.radius
        }
    }
    fn main() {
        let c = Circle { radius : 2f64};
        // 编译错误
        // c.area();
        let b = Box::new(Circle {radius : 4f64});
        // 编译正确
        b.area();
    }
```

impl的对象甚至可以是trait

```
    trait Shape {
        fn area(&self) -> f64;
    }

    trait Round {
        fn get_radius(&self) -> f64;
    }
    struct Circle {
        radius: f64,
    }
    impl Round for Circle {
        fn get_radius(&self) -> f64 { self.radius }
    }
    // 注意这里是 impl Trait for Trait
    impl Shape for Round {
        fn area(&self) -> f64 {
            std::f64::consts::PI ＊ self.get_radius() ＊ self.get_radius()
        }
    }
    fn main() {
        let c = Circle { radius : 2f64};
        // 编译错误
        // c.area();
        let b = Box::new(Circle {radius : 4f64}) as Box<Round>;
        // 编译正确
        b.area();
    }
```

注意这里的写法，impl Shape for Round和impl<T: Round> Shape for T是不一样的。在前一种写法中，self是&Round类型，它是一个trait object，是胖指针。而在后一种写法中，self是&T类型，是具体类型。前一种写法是为trait object增加一个成员方法，而后一种写法是为所有的满足T: Round的具体类型增加一个成员方法。

**在声明trait和impl trait的时候，Rust规定了一个Coherence Rule（一致性规则）或称为Orphan Rule（孤儿规则）:impl块要么与trait的声明在同一个的crate中，要么与类型的声明在同一个crate中。**

### 静态方法

没有receiver参数的方法（第一个参数不是self参数的方法）。通过Type::FunctionName()的方式调用。

```
    struct T(i32);
    impl T {
        // 这是一个静态方法
        fn func(this: &Self) {
            println!{"value {}", this.0};
        }
    }
    fn main() {
        let x = T(42);
        // x.func(); 小数点方式调用是不合法的
        T::func(&x);
    }
```

trait中也可以定义静态函数
```
    pub trait Default {
        fn default() -> Self;
    }

    // 这里用到了“泛型”，请参阅第21章
    impl<T> Default for Vec<T> {
        fn default() -> Vec<T> {
            Vec::new()
        }
    }
```

这样的写法是错误的。请一定要记住，trait的大小在编译阶段是不固定的。
```
    let x: Shape = Circle::new(); // Shape 不能做局部变量的类型
    fn use_shape(arg : Shape) {}  // Shape 不能直接做参数的类型
    fn ret_shape() -> Shape {}     // Shape 不能直接做返回值的类型
```

**目前版本的Rust规定，在函数参数传递、返回值传递等地方，都要求这个类型在编译阶段有确定的大小。**


### 完整函数调用语法

```
    trait Cook {
        fn start(&self);
    }
    trait Wash {
        fn start(&self);
    }
    struct Chef;
    impl Cook for Chef {
        fn start(&self) { println!("Cook::start"); }
    }
    impl Wash for Chef {
        fn start(&self) { println!("Wash::start"); }
    }

    fn main() {
        let me = Chef;
        me.start();// 出现歧义

    }

    fn main() {//无歧义
        let me = Chef;
        // 函数名字使用更完整的path来指定，同时，self参数需要显式传递
        <Cook>::start(&me);
        <Chef as Wash>::start(&me);
    }
```

### trait约束和继承

```
    use std::fmt::Debug;
    fn my_print<T : Debug>(x: T) {
        println!("The value is {:? }.", x);
    }
    fn main() {
        my_print("China");
        my_print(41_i32);
        my_print(true);
        my_print(['a', 'b', 'c'])
    }
```

冒号后面加trait名字，就是这个泛型参数的约束条件。它要求这个T类型实现Debug这个trait。这是因为我们在函数体内，用到了println！格式化打印，而且用了{:? }这样的格式控制符，它要求类型满足Debug的约束，否则编译不过。


另外写法

```
    fn my_print<T>(x: T) where T: Debug {
        println!("The value is {:? }.", x);
    }
```

trait继承

```
    trait Base {}
    trait Derived : Base {}
    struct T;
    impl Derived for T {}
    impl Base for T {} //必须实现Base和Derived，必须两个都实现，不然编译报错
    fn main() {
    }
```


