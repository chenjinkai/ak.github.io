---
title: "Nacos客户端NamingClient源码分析"
categories: 
 - 技术
tags:
 - Nacos
date: 2025/04/14 13:31:00
updated: 2025/04/14 13:31:00
---

话不多说，先上一个类图。NamingClientProxyDelegate是这一块比较核心的类，像一个装配工厂一样，将各个工具类组装起来，对外提供接口。

![Nacos客户端NamingClient](1.png)
<!--more-->

这边学习研究的客户端源代码为spring-cloud-starter-alibaba-nacos-discovery-2021.0.5.0版本，对应的nacos-client-2.2.0版本。

### grpc or http

grpcClientProxy和httpClientProxy都是NamingClientProxy的子类，grpcClientProxy是使用grpc协议，httpClientProxy是使用http协议。

```
    //NamingClientProxyDelegate.java
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        getExecuteClientProxy(instance).registerService(serviceName, groupName, instance);
    }

    private NamingClientProxy getExecuteClientProxy(Instance instance) {
        return instance.isEphemeral() ? grpcClientProxy : httpClientProxy;
    }
```

getExecuteClientProxy方法只有在NamingClientProxyDelegate的registerService和deregisterService方法中才会被使用。delegate中其他方法都是直接用grpc协议

![grpc](3.png)

只有registerService，deregisterService，serverHealthy方法可能会用到http协议。

**http服务注册方式，没多少好讲的。http的可靠性和性能，肯定比不上grpc。nacos-client grpcClientProxy加入了重试和事件订阅机制。请求的可靠性和服务调用实例上下线感知的时效性都要比http好。后续都将grpc的实现逻辑。**


### 服务实例注册

服务注册的发起动作，是嵌入在spring容器启动阶段。服务器注册这边按照临时和持久化服务注册方式，使用不同的客户端实现。

![服务注册调用栈](2.png)


```
    // NamingGrpcClientProxy.java
    public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {
        NAMING_LOGGER.info("[REGISTER-SERVICE] {} registering service {} with instance {}", namespaceId, serviceName,
                instance);
        redoService.cacheInstanceForRedo(serviceName, groupName, instance);
        doRegisterService(serviceName, groupName, instance);
    }

    public void doRegisterService(String serviceName, String groupName, Instance instance) throws NacosException {
        InstanceRequest request = new InstanceRequest(namespaceId, serviceName, groupName,
                NamingRemoteConstants.REGISTER_INSTANCE, instance);
        requestToServer(request, Response.class);
        redoService.instanceRegistered(serviceName, groupName);
    }
```

**这段服务注册的代码干了如下几件事情：**
1. redoService缓存服务实例，如果服务实例注册、注销或者订阅和取消订阅，会进行重试
2. requestToServer发起请求，将服务实例注册到nacos服务端
3. redoService.instanceRegistered，标记服务已经成功注册

```
// RedoScheduledTask.java
    public void run() {
        if (!redoService.isConnected()) {
            LogUtils.NAMING_LOGGER.warn("Grpc Connection is disconnect, skip current redo task");
            return;
        }
        try {
            redoForInstances();
            redoForSubscribes();
        } catch (Exception e) {
            LogUtils.NAMING_LOGGER.warn("Redo task run with unexpected exception: ", e);
        }
    }


```

### 服务实例订阅




